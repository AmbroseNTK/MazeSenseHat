import sense_hat
import time
#!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-
s = sense_hat
#!-!-!-!-!-!-!-!-!-!-!-!-!-!-!-
#editable var
Map_a = 'D:\Pi\MazeMap\Map1a.txt'
Map_c = 'D:\Pi\MazeMap\Map1c.txt'
#constant var
width =  32
height = 32
maze = []
graphicMaze = []
player = [3,27]
pixels = []
gameover = False
startPosition = [3,27]
black = (0,0,0)
playerColor = (0,255,255)
#methods
#space = 0, wall = 1, player = 2, goal = 3, border color it 

def InitMaze():
  for i in range(0,64):
    pixels.append(black)
  for i in range(0,height):
    for k in range(0,width):
      maze.append(0)
      graphicMaze.append(black)

def InitGame():
  fileMapa = open(Map_a,'r')
  fileMapc = open(Map_c,'r')
  global width
  global height
  width = fileMapa.readline()
  height = fileMapa.readline()
  playerColor = fileMapa.readline()
  player = ConvertIndexFrom2DArrayTo1DArray(fileMapa.readline(),width,height)
  startPosition = player;
  #
  InitMaze()
  #
  for i in range(0,height):
    for k in range(0,width):
      index = i*width + k
      maze[index] = fileMapa.readline()
      graphicMaze[index] = fileMapc.readline()
  fileMapa.close()
  fileMapc.close()
      

def ConvertIndexFrom2DArrayTo1DArray(index1D,Width2D,Height2D):
  x = int(index1D % Width2D)
  y = int((index1D - x)/Height2D)
  return [x,y]

def GetPlayerGraphicPosition():
  result = [0,0,0,0]
  result[0] = player[1] * width + player[0]
  result[1] = player[1] * width + player[0] + 1
  result[2] = (player[1] + 1) * width + player[0]
  result[3] = (player[1] + 1) * width + player[0] + 1
  return result

def SetPlayerValueOnMap(value):
  playerGraphicIndex = GetPlayerGraphicPosition()
  maze[playerGraphicIndex[0]] = value
  maze[playerGraphicIndex[1]] = value
  maze[playerGraphicIndex[2]] = value
  maze[playerGraphicIndex[3]] = value

def CheckAvailableTop():
  v1 = (player[1] -1) * width + player[0]
  v2 = (player[1] -1) * width + player[0] + 1
  if maze[v1] == 0 and maze[v2] == 0:
    return 1
  elif maze[v1] == 3 and maze[v2] == 3:
    return 2
  return 0
  
def CheckAvailableDown():
  v1 = (player[1] + 2) * width + player[0]
  v2 = (player[1] + 2) * width + player[0] + 1
  if maze[v1] == 0 and maze[v2] == 0:
    return 1
  elif maze[v1] == 3 and maze[v2] == 3:
    return 2
  return 0

def CheckAvailableLeft():
  v1 = player[1] * width + player[0] - 1
  v2 = (player[1] + 1) * width + player[0] - 1
  if maze[v1] == 0 and maze[v2] == 0:
    return 1
  elif maze[v1] == 3 and maze[v2] == 3:
    return 2
  return 0
  
def CheckAvailableRight():
  v1 = player[1] * width + player[0] + 2
  v2 = (player[1] + 1) * width + player[0] + 2
  if maze[v1] == 0 and maze[v2] == 0:
    return 1
  elif maze[v1] == 3 and maze[v2] == 3:
    return 2
  return 0

def Render():
  for i in range(0,8):
    for k in range(0,8):
      pIndex = i*8 + k
      mIndex = (player[1] - 3 + i)* width + (player[0] - 3) + k 
      pixels[pIndex] = graphicMaze[mIndex]
  
  SetPlayerValueOnMap(2)
  pixels[27] = playerColor
  pixels[28] = playerColor
  pixels[35] = playerColor
  pixels[36] = playerColor
  s.SenseHat().set_pixels(pixels)
  time.sleep(0.020)



def GetInputCode():
  global s
  events = hat.stick.get_events()
  if len(events)>0:
    if events[0].action !='release':
      e = events[0]
      if e.direction == 'up':
        return 1
      elif e.direction == 'down':
        return 2
      elif e.direction == 'left':
        return 3
      elif e.direction == 'right':
        return 4
      #elif e.direction == s.DIRECTION_MIDDLE and e.action == s.ACTION_PRESSED:
       #return 5


def ValidatePlayerPosition():
  if player[1] < 3:
    player[1] = 3
  if player[1] > height - 5:
    player[1] = height - 5
  if player[0] < 3:
    player[0] = 3
  if player[0] > width - 5:
    player[0] = width - 5
    

def InputProcessing():
  #
  SetPlayerValueOnMap(0)
  playerGraphicIndex = GetPlayerGraphicPosition()
  #
  inputCode = GetInputCode()
  if inputCode == 1: #and CheckAvailableTop() == 1: #UP
    player[1] -= 1
  elif inputCode == 2: #and CheckAvailableDown() == 1: #DOWN
    player[1] += 1
  elif inputCode == 3: #and CheckAvailableLeft() == 1: #LEFT
    player[0] -= 1
  elif inputCode == 4: #and CheckAvailableRight() == 1: #RIGHT
    player[0] += 1
  elif CheckAvailableTop() == 2 or CheckAvailableDown() == 2 or CheckAvailableLeft() == 2 or CheckAvailableRight() == 2:
    GameOver()
  #elif inputCode == 5: #Reset
    #reset game
  ValidatePlayerPosition()
  SetPlayerValueOnMap(2)

def ResetGame():
  player = startPositon
  Render()

def GameOver():
  gameover = True
  
InitGame()
while True:
  while gameover == False:
    InputProcessing()
    Render()
  s.SenseHat().show_message('win')
  if GetInputCode() == 5:
    gameover = False
    ResetGame()
  
  
